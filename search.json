[{"path":"https://rwparsons.github.io/circacompare/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 circacompare authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"updates-since-the-initial-release-circacompare-0-1-0-and-bioinformatics-journal-article-","dir":"Articles","previous_headings":"","what":"Updates since the initial release (circacompare 0.1.0) and Bioinformatics journal article.","title":"Introduction to circacompare","text":"several added features current version circacompare package since publication Bioinformatics initial release CRAN. Many possible uses package described manuscript. approach compare two groups rhythmic data, regarding mesor, amplitude phase, described manuscript, can completed using circacompare() function default settings version package. addition , current version offers approaches : Perform analysis single rhythmic dataset estimate mesor, amplitude phase. Choose use known period (user-determined) let model estimate period data. Add parameters estimate exponential decay rhythmic characteristics. Use mixed-model instead fixed effects model take account within-subject correlation regarding set rhythmic characteristics. Perform comparison groups regarding subset rhythmic characteristics.","code":""},{"path":[]},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"input-data","dir":"Articles","previous_headings":"Introduction to circacompare, using fixed-effects only models and no customized model parametrization","what":"Input data","title":"Introduction to circacompare","text":"first part using circacompare analyse data ensure data formatted correctly. functions within circacompare package expect data tidy format, meaning row contain one observation, columns represent time, group subject ID observation. simplest case, may single rhythm ’re wanting estimate mesor, amplitude phase. case, need variable time observation outcome ’re wanting model. case data two groups ’re wishing determine differences mesor, amplitude, phase , need additional column (two possible values) representing groups.","code":"library(circacompare) library(ggplot2) set.seed(42) data_single <- make_data(k1 = 0, alpha1 = 0, phi1 = 0, noise_sd = 1)[c(\"time\", \"measure\")] head(data_single) #>   time    measure #> 1    1 11.0302167 #> 2    2  8.0955559 #> 3    3  7.4341962 #> 4    4  5.6328626 #> 5    5  2.9924588 #> 6    6 -0.1061245 data_grouped <- make_data(phi1 = 6, noise_sd = 1) head(data_grouped) #>   time  measure group #> 1    1 8.527520    g1 #> 2    2 7.201040    g1 #> 3    3 7.151050    g1 #> 4    4 5.653204    g1 #> 5    5 3.789156    g1 #> 6    6 1.044751    g1 tail(data_grouped) #>    time  measure group #> 91   43 10.95842    g2 #> 92   44 13.66312    g2 #> 93   45 14.43497    g2 #> 94   46 15.00277    g2 #> 95   47 17.20176    g2 #> 96   48 16.09730    g2"},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"circa_single","dir":"Articles","previous_headings":"Introduction to circacompare, using fixed-effects only models and no customized model parametrization","what":"circa_single()","title":"Introduction to circacompare","text":"circa_single() used analyse single rhythm provide estimates mesor, amplitude phase.  fitted model included first element results. fits model: measure ~ k + alpha * cos(time_r - phi) measure outcome interest k mesor alpha amplitude time_r time radian-hours, phi amount phase shift (time=0) radian-hours. parameter estimates time radian-hours (time_r phi) converted back hours reported data.frame (second element list) x-axis graph (third item list)","code":"result <- circa_single(x = data_single, col_time = \"time\", col_outcome = \"measure\", period = 24)  result #> $fit #> Nonlinear regression model #>   model: measure ~ k + (alpha) * cos((1/period) * time_r - (phi)) #>    data: x #>        k    alpha      phi  #>  0.05322 10.07049  0.01645  #>  residual sum-of-squares: 101.8 #>  #> Number of iterations to convergence: 5  #> Achieved convergence tolerance: 1.141e-07 #>  #> $summary #>         parameter        value #> 1      rhythmic_p 2.524709e-80 #> 2           mesor 5.322133e-02 #> 3       amplitude 1.007049e+01 #> 4   phase_radians 1.645014e-02 #> 5 peak_time_hours 6.283491e-02 #> 6          period 2.400000e+01 #>  #> $plot"},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"circacompare","dir":"Articles","previous_headings":"Introduction to circacompare, using fixed-effects only models and no customized model parametrization","what":"circacompare()","title":"Introduction to circacompare","text":"circacompare() used analyse dataset two groups rhythmic data. fits model estimate statistically support differences mesor, amplitude phase two groups.  fits model: measure ~ k + k1 * x_group + (alpha + alpha1 * x_group) * cos(time_r - (phi + phi1 * x_group)) x_group dummy variable represents different groups: x_group=0 x_group=1 first second group, respectively measure outcome interest k mesor first group k1 difference mesor first second group alpha amplitude first group alpha1 difference amplitude first second group time_r time radian-hours phi amount phase-shift first group (time=0) radian-hours, phi1 amount phase-shift second group first group radian-hours time-related parameter estimates (phi phi1) converted radian-hours hours used report g1 peak time, g2 peak time, phase difference estimate. second item result2 list data.frame containing important results model. returns estimates rhythmic parameters group well p-values associated represent differences groups (k1, alpha1, phi1). detailed outputs model can obtained model ","code":"result2 <- circacompare(x = data_grouped, col_time = \"time\", col_group = \"group\", col_outcome = \"measure\")  result2 #> $plot #>  #> $summary #>                                   parameter         value #> 1  Presence of rhythmicity (p-value) for g1  3.232079e-41 #> 2  Presence of rhythmicity (p-value) for g2  3.863382e-50 #> 3                         g1 mesor estimate -1.842953e-01 #> 4                         g2 mesor estimate  2.921261e+00 #> 5                 Mesor difference estimate  3.105556e+00 #> 6              P-value for mesor difference  2.041190e-29 #> 7                     g1 amplitude estimate  9.767675e+00 #> 8                     g2 amplitude estimate  1.408205e+01 #> 9             Amplitude difference estimate  4.314378e+00 #> 10         P-value for amplitude difference  6.866192e-29 #> 11                       g1 peak time hours  2.396898e+01 #> 12                       g2 peak time hours  2.294131e+01 #> 13                Phase difference estimate -1.027669e+00 #> 14          P-value for difference in phase  1.138807e-19 #> 15                   Shared period estimate  2.400000e+01 #>  #> $fit #> Nonlinear regression model #>   model: measure ~ (k + k1 * x_group) + ((alpha + alpha1 * x_group)) *     cos((1/period) * time_r - ((phi + phi1 * x_group))) #>    data: x #>       k      k1   alpha  alpha1     phi    phi1  #> -0.1843  3.1056  9.7677  4.3144 12.5582 -0.2690  #>  residual sum-of-squares: 74.18 #>  #> Number of iterations to convergence: 4  #> Achieved convergence tolerance: 7.333e-08"},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"when-to-use-what","dir":"Articles","previous_headings":"Introduction to circacompare, using fixed-effects only models and no customized model parametrization","what":"When to use what","title":"Introduction to circacompare","text":"looking estimate rhythmic parameters single group, use circa_single(). looking estimate differences two rhythmic datasets, use circacompare() data hierarchical structure, mixed model may appropriate (keep reading). may case repeated measurements subjects/tissues time, example. case, consider equivalents : circa_single_mixed() circacompare_mixed(). addition described, mixed models require user specify parameters random effect identifying column (col_id) hierarchical structure.","code":""},{"path":[]},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"firstly-a-mention-on-control-and-model-parameters","dir":"Articles","previous_headings":"Mixed-model variants and how to customize the parameterization of the model","what":"Firstly, a mention on control and model parameters","title":"Introduction to circacompare","text":"refer parameters, talking covariates model fit represent rhythmic characteristics data. Arguments user () supplies calling function. circacompare functions, argument control contains list optional arguments can used modify parameterization model fit. list includes main_params, decay_params, rand_params, group_params character vectors. naming conventions values within vectors consistent model formulas described earlier: “k” mesor, “alpha” amplitude, “phi” phase. additional parameter introduce “tau” period. circa_single() groups model differences group_params ignored. Since also random effects, rand_params also ignored. main_params decay_params considered. Similarly, circacompare() considers main_params, decay_params, ignores rand_params(), also includes group_params used consider differences groups. mixed-model variants two functions, circa_single_mixed() circacompare_mixed(), consider rand_params. main_params vector, possible values k mesor, alpha amplitude, phi phase, tau. optional parameter main_params tau, rest must included times. default main_params=c(\"k\", \"alpha\", \"phi\"), excludes parameterization period model. values within decay_params must set within main_params , example, can’t model decay period, without modeling starting period. default model decay rhythmic characteristics: decay_params=c(). Additional possible arguments control list : period_param adds \"tau\" main_params TRUE; default: period_param=FALSE. period_min estimated bottom range period starting values performing nonlinear regression; default: period_min=20. period_max estimated upper range period starting values performing nonlinear regression; period_max=28, modeling non-circadian (still rhythmic) data, much larger smaller period 24 hours, want model estimate period (tau) can change period_min period_max realistic ranges. may reduce time required model converge. Note adding parameters decay_params, call name parameter main_params - decay_params=c(\"k\"), example. add new parameter k_decay model. want add grouping parameter decay parameter, need call decay mesor explicitly, group_params=c(\"k_decay\"), \"k\" alone referring mesor value, decay mesor time. Similarly, adding parameters random-effects adding rand_params, need call parameter name (including ’s suffix: “_decay” decay parameters “1” group parameters, “_decay1” grouped decay parameters). wanted fit model default main_params well period (tau), decay mesor (k), grouping mesor decay rate, amplitude phase, starting mesor: control=list(main_params=c(\"k\", \"alpha\", \"phi\", \"tau\"), decay_params=c(\"k\"), group_params=c(\"k_decay\", \"alpha\", \"phi\")) resulting model assume groups shared mesor period \"k\" \"tau\", respectively, excluded group_params. model estimate period data. model exponential decay mesor well influence group assignment rate decay.","code":""},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"examples","dir":"Articles","previous_headings":"Mixed-model variants and how to customize the parameterization of the model","what":"Examples","title":"Introduction to circacompare","text":"repeated measures data, may inappropriate use standard fixed effects model. case, use mixed model, context-relevant random effects ID/subjects/mice ’re obtaining repeated observations. , data simulated within-id correlation terms amount phase shift groups.  subject (id), measurements groups (g1 g2) degree change phase g1 g2 subject-dependent. phase group 1 subject-dependent, though, subject approximately phase g1. However, ’s amount phase shift g1 g2 subject-dependent. equivalent subject random slope term random intercept. experimental context, case mice kept light-dark (LD) conditions g1 moved constant conditions (LL DD), g2. expect phase consistent conditions g1 change phase moved LL DD mouse-dependent. scenario, want “random-slope” phase, include phi1 random effect. Also, since know (data generating process) groups share mesor amplitude, included alpha phi grouped parameters, excluded k. also know period 24 hours, didn’t bother fitting parameter period either (adding \"tau\" main_params) left main_params default value: main_params=c(\"k\", \"alpha\", \"phi\"). code , used: control=list(grouped_params=c(\"alpha\", \"phi\"), random_params=c(\"phi1\")) data generating process used , expect: phi1=3 alpha1=5  effects pretty well estimated, given 95% confidence intervals model outputs. expect subject’s different starting phases change phase groups , may put random effect phi rather phi1. Perhaps commonly applicable subject random mesor baseline expression level. case, may worthwhile include k random effect. k included, equivalent giving subjects “random intercept” baseline levels outcome subject random effect.","code":"phi1_in <- 3 mixed_data <- function(n) {   counter <- 1   for (i in 1:n) {     x <- make_data(k1 = 0, alpha1 = 5, phi1 = rnorm(1, phi1_in, 1), hours = 72, noise_sd = 2)     x$id <- counter     counter <- counter + 1     if (i == 1) {       res <- x     } else {       res <- rbind(res, x)     }   }   return(res) } df <- mixed_data(20) out <- circacompare_mixed(   x = df,   col_time = \"time\",   col_group = \"group\",   col_outcome = \"measure\",   col_id = \"id\",   control = list(grouped_params = c(\"alpha\", \"phi\"), random_params = c(\"phi1\")),   period = 24,   suppress_all = TRUE )  ggplot(data = df[df$id %in% c(1:6), ], aes(time, measure)) +   geom_point(aes(col = group)) +   geom_smooth(aes(group = interaction(as.factor(id), group)), span = 0.3) +   facet_wrap(~id) out$plot summary <- as.data.frame(circacompare:::extract_model_coefs(out$fit)) summary$`95% CI ll` <- summary$estimate - summary$std_error * 1.96 summary$`95% CI ul` <- summary$estimate + summary$std_error * 1.96  summary #>            estimate   std_error      p_value    95% CI ll   95% CI ul #> k      -0.030108418 0.037543899 4.226472e-01 -0.103694459  0.04347762 #> alpha   9.973999567 0.075087709 0.000000e+00  9.826827657 10.12117148 #> phi     0.005516318 0.007528311 4.637752e-01 -0.009239171  0.02027181 #> alpha1  5.099811194 0.106190057 0.000000e+00  4.891678682  5.30794370 #> phi1    2.992445863 0.193146837 4.776699e-52  2.613878062  3.37101366"},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"period-and-decay-parameters","dir":"Articles","previous_headings":"","what":"Period and decay parameters","title":"Introduction to circacompare","text":"option add parameters represent decay rhythmic characteristic well difference groups decay. model , make simulated data difference mesor phase groups, randomly generated period 8 20 hours want estimate (check end). also one group exponentially decaying amplitude rate: \\[ \\alpha*e^{-\\alpha_{decay}*t} \\] alpha amplitude, t time radian-hours. case, alpha_decay another randomly generated value, somewhere 0.02 0.05, check end. model data, include standard parameters well tau (estimate period) main_params: main_params=c(\"k\", \"alpha\", \"phi\", \"tau\") include term amplitude (alpha) decay_params: decay_params=c(\"alpha\") model differences groups starting amplitude,alpha, decay time alpha_decay: grouped_params=c(\"alpha\", \"alpha_decay\") produces following model: measure~k+((alpha+alpha1*x_group)*exp(-(alpha_decay+alpha_decay1*x_group)*time_r))*cos((24/(tau))*time_r-(phi))  now estimates 95% confidence intervals difference amplitude decay groups (alpha_decay1) period (tau) interest. Lets see values used generate data check confidence intervals appropriate. Looks like estimates confidence intervals suited now-known data generating process well!","code":"tau_in <- runif(1, 8, 20) alpha_decay1_in <- runif(1, 0.02, 0.05)  df <- make_data(k1 = 0, alpha1 = 10, phi1 = 0, seed = 42, hours = 120, noise_sd = 2) df$time <- df$time / 24 * tau_in  # Note that when decay is estimated, it is on a scale of time in hours. There is no relation decay rate and the period. df$measure[df$group == \"g2\"] <- df$measure[df$group == \"g2\"] * exp(-alpha_decay1_in * df$time[df$group == \"g2\"])  out_alpha_decay <-   circacompare(     x = df, \"time\", \"group\", \"measure\", period = NA,     control = list(       main_params = c(\"k\", \"alpha\", \"phi\", \"tau\"),       decay_params = c(\"alpha\"),       grouped_params = c(\"alpha\", \"alpha_decay\"),       period_min = 2, period_max = 24     )   ) #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   step factor 0.000488281 reduced below 'minFactor' of 0.000976562 #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   step factor 0.000488281 reduced below 'minFactor' of 0.000976562 #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   number of iterations exceeded maximum of 50 #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   step factor 0.000488281 reduced below 'minFactor' of 0.000976562 #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   number of iterations exceeded maximum of 50 #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   number of iterations exceeded maximum of 50 #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   step factor 0.000488281 reduced below 'minFactor' of 0.000976562 #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   number of iterations exceeded maximum of 50 #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   step factor 0.000488281 reduced below 'minFactor' of 0.000976562 #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   step factor 0.000488281 reduced below 'minFactor' of 0.000976562 #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient #> Error in numericDeriv(form[[3L]], names(ind), env, central = nDcentral) :  #>   Missing value or an infinity produced when evaluating the model #> Error in stats::nls(formula = form, data = data, start = starting_params,  :  #>   singular gradient  out_alpha_decay$plot summary <- as.data.frame(circacompare:::extract_model_coefs(out_alpha_decay$fit)) summary$`95% CI ll` <- summary$estimate - summary$std_error * 1.96 summary$`95% CI ul` <- summary$estimate + summary$std_error * 1.96 summary$p_value <- NULL summary #>                   estimate    std_error    95% CI ll    95% CI ul #> k            -3.395691e-02 0.1013869255 -0.232675281  0.164761467 #> alpha         1.009223e+01 0.4052065165  9.298025134 10.886434679 #> alpha_decay   5.435973e-05 0.0007432627 -0.001402435  0.001511155 #> alpha1        8.632203e+00 0.8813658989  6.904725702 10.359680026 #> alpha_decay1  3.739104e-02 0.0023140206  0.032855564  0.041926524 #> tau           1.850420e+01 0.0327072885 18.440090205 18.568302776 #> phi           1.338657e-02 0.0270874943 -0.039704918  0.066478060 cat(\"Real period: \", tau_in, \"\\n\",   \"Real alpha_decay: \", alpha_decay1_in,   sep = \"\" ) #> Real period: 18.50667 #> Real alpha_decay: 0.03999372"},{"path":[]},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"decay-functions","dir":"Articles","previous_headings":"Limitations","what":"Decay functions","title":"Introduction to circacompare","text":"Currently, decay parameters used model exponential decay seemed sensible biological contexts. However, users may want model decay linear () function. implementation current package. interest , please contact create issue GitHub.","code":""},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"period-and-phase-parameters","dir":"Articles","previous_headings":"Limitations","what":"Period and phase parameters","title":"Introduction to circacompare","text":"may tempting investigate differences two groups rhythmic data regarding everything! , unfortunately, limitations. two groups data allowed vary regarding period, interpretation difference phase longer appropriate. example, two rhythms different periods, time wanting know difference phase groups? amount phase-shift differ time different periods. reason, tau phi within group_params either circacompare() circacompare_mixed().","code":""},{"path":"https://rwparsons.github.io/circacompare/articles/circacompare-vignette.html","id":"model-diagnostics-and-choice","dir":"Articles","previous_headings":"Limitations","what":"Model diagnostics and choice","title":"Introduction to circacompare","text":"using circa_single() circacompare() nonlinear regression model (fixed-effects ) class nls fit. using circa_single_mixed() circacompare_mixed() nonlinear mixed regression model class nlme fit. Users aware assumptions models interpreting results. See thorough discussion model assumptions performing diagnostic tests using nlstools package.","code":""},{"path":"https://rwparsons.github.io/circacompare/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rex Parsons. Author, maintainer. Alexander Bender. Contributor.","code":""},{"path":"https://rwparsons.github.io/circacompare/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rex Parsons, Richard Parsons, Nicholas Garner, Henrik Oster,  Oliver Rawashdeh, CircaCompare: method estimate  statistically support differences mesor, amplitude phase,  circadian rhythms, Bioinformatics, Volume 36, Issue 4, 15  February 2020, Pages 1208–1212,  https://doi.org/10.1093/bioinformatics/btz730","code":"@Article{,   title = {CircaCompare: a method to estimate and statistically support differences in mesor, amplitude and phase, between circadian rhythms},   author = {Rex Parsons and Richard Parsons and Nicholas Garner and Henrik Oster and Oliver Rawashdeh},   journal = {Bioinformatics},   year = {2020},   volume = {36},   number = {4},   pages = {1208-1212},   url = {https://doi.org/10.1093/bioinformatics/btz730},   doi = {10.1093/bioinformatics/btz730}, }"},{"path":"https://rwparsons.github.io/circacompare/index.html","id":"circacompare","dir":"","previous_headings":"","what":"Analyses of Circadian Data","title":"Analyses of Circadian Data","text":"circacompare R package allows statistical analyses comparison two circadian rhythms. work published can cited : Rex Parsons, Richard Parsons, Nicholas Garner, Henrik Oster, Oliver Rawashdeh, CircaCompare: method estimate statistically support differences mesor, amplitude, phase, circadian rhythms, Bioinformatics, https://doi.org/10.1093/bioinformatics/btz730 several improvements package since initial release. addition available 1.0.0 described publication, package offers approaches : * Perform analysis single rhythmic dataset estimate mesor, amplitude phase. * Choose use known period (user-determined) let model estimate period data. * Add parameters estimate exponential decay rhythmic characteristics. * Use mixed-model instead fixed effects model take account within-subject correlation regarding set rhythmic parameters. * Perform comparison groups subset rhythmic characteristics. Please see vignette full details examples features.","code":"browseVignettes(package=\"circacompare\")"},{"path":[]},{"path":"https://rwparsons.github.io/circacompare/index.html","id":"installing-from-cran","dir":"","previous_headings":"","what":"Installing from CRAN","title":"Analyses of Circadian Data","text":"","code":"install.packages(\"circacompare\")"},{"path":"https://rwparsons.github.io/circacompare/index.html","id":"installing-development-version-from-github","dir":"","previous_headings":"","what":"Installing development version from GitHub","title":"Analyses of Circadian Data","text":"done already, install devtools using following code: install circacompare directly using following code:","code":"install.packages(\"devtools\") devtools::install_github(\"RWParsons/circacompare\")"},{"path":"https://rwparsons.github.io/circacompare/index.html","id":"help","dir":"","previous_headings":"","what":"Help","title":"Analyses of Circadian Data","text":"loaded R, load documentation using ?circacompare. per example, can use function, make_data, generate example data appropriate use circacompare function. ’re troubles suggestions improvement, please create issue email (rex.parsons94@gmail.com).","code":""},{"path":"https://rwparsons.github.io/circacompare/index.html","id":"shinyr-application","dir":"","previous_headings":"","what":"ShinyR application","title":"Analyses of Circadian Data","text":"implementation circacompare program available Shiny app : https://rwparsons.shinyapps.io/circacompare/ data uploaded csv format. file upload columns : 1. time variable (numeric hours) 2. grouping variable (can format must two possible values) 3. outcome variable (numeric) Upload csv file select respective columns dropdown menu. Click ‘run’ conduct comparison.","code":""},{"path":"https://rwparsons.github.io/circacompare/index.html","id":"python-implementation","dir":"","previous_headings":"","what":"Python implementation","title":"Analyses of Circadian Data","text":"implementation package Python available . package comes added functionality specification loss function.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single.html","id":null,"dir":"Reference","previous_headings":"","what":"circa_single — circa_single","title":"circa_single — circa_single","text":"circa_single performs analysis single rhythmic dataset. estimates mesor, amplitude phase data provided.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"circa_single — circa_single","text":"","code":"circa_single(   x,   col_time,   col_outcome,   period = 24,   alpha_threshold = 0.05,   timeout_n = 10000,   return_figure = TRUE,   control = list(),   weights = NULL,   suppress_all = FALSE )"},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"circa_single — circa_single","text":"x data.frame.  data.frame contains rhythmic data tidy format. col_time name column within data.frame, x, contains time hours data collected. col_outcome name column within data.frame, x, contains outcome measure interest. period period rhythm. circadian rhythms, leave default value, 24. alpha_threshold level alpha presence rhythmicity considered. Default 0.05. timeout_n upper limit model fitting attempts. Default 10,000. return_figure Whether return ggplot graph rhythm cosine model. control list. Used control parameterization model. weights optional numeric vector (fixed) weights. present, objective function weighted least squares. suppress_all Logical. Set TRUE avoid seeing errors messages model fitting procedure. Default FALSE.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"circa_single — circa_single","text":"list","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"circa_single — circa_single","text":"","code":"df <- make_data() df <- df[df$group == \"g1\", ] out <- circa_single(x = df, col_time = \"time\", col_outcome = \"measure\") #> Error in stats::nls(formula = form, data = x, start = start_list(outcome = x$measure,  :  #>   step factor 0.000488281 reduced below 'minFactor' of 0.000976562 out #> $fit #> Nonlinear regression model #>   model: measure ~ k + (alpha) * cos((1/period) * time_r - (phi)) #>    data: x #>         k     alpha       phi  #> -0.005305  9.997607  6.282388  #>  residual sum-of-squares: 0.4548 #>  #> Number of iterations to convergence: 6  #> Achieved convergence tolerance: 6.178e-06 #>  #> $summary #>         parameter         value #> 1      rhythmic_p  2.094669e-85 #> 2           mesor -5.304617e-03 #> 3       amplitude  9.997607e+00 #> 4   phase_radians  6.282388e+00 #> 5 peak_time_hours  2.399695e+01 #> 6          period  2.400000e+01 #>  #> $plot  #>   # with sample weights (arbitrary weights for demonstration) sw <- runif(n = nrow(df)) out2 <- circa_single(   x = df,   col_time = \"time\",   col_outcome = \"measure\",   weights = sw,   suppress_all = TRUE ) out2 #> $fit #> Nonlinear regression model #>   model: measure ~ k + (alpha) * cos((1/period) * time_r - (phi)) #>    data: x #>        k    alpha      phi  #> -0.01776  9.99622  6.28158  #>  weighted residual sum-of-squares: 0.1958 #>  #> Number of iterations to convergence: 8  #> Achieved convergence tolerance: 1.473e-07 #>  #> $summary #>         parameter         value #> 1      rhythmic_p  5.234639e-88 #> 2           mesor -1.775707e-02 #> 3       amplitude  9.996223e+00 #> 4   phase_radians  6.281576e+00 #> 5 peak_time_hours  2.399385e+01 #> 6          period  2.400000e+01 #>  #> $plot  #>"},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single_mixed.html","id":null,"dir":"Reference","previous_headings":"","what":"circa_single_mixed — circa_single_mixed","title":"circa_single_mixed — circa_single_mixed","text":"circa_single_mixed similar circa_single allows simple, user-specified random-effects rhythmic parameters choice.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single_mixed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"circa_single_mixed — circa_single_mixed","text":"","code":"circa_single_mixed(   x,   col_time,   col_outcome,   col_id,   randomeffects = c(\"k\", \"alpha\", \"phi\"),   period = 24,   alpha_threshold = 0.05,   nlme_control = list(),   nlme_method = \"ML\",   weights = NULL,   suppress_all = FALSE,   timeout_n = 10000,   return_figure = TRUE,   control = list() )"},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single_mixed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"circa_single_mixed — circa_single_mixed","text":"x data.frame.  data.frame contains rhythmic data tidy format. col_time name column within data.frame, x, contains time hours data collected. col_outcome name column within data.frame, x, contains outcome measure interest. col_id name column within data.frame, x, contains identifying values random effect, subject_id. randomeffects rhythmic parameters allow random effects. default include rhythmic parameters. period period rhythm. circadian rhythms, leave default value, 24. alpha_threshold level alpha presence rhythmicity considered. Default 0.05. nlme_control list control values estimation algorithm replace default values returned function nlme::nlmeControl. Defaults empty list. nlme_method character string. \"REML\" model fit maximizing restricted log-likelihood. \"ML\" log-likelihood maximized. Defaults \"ML\". weights optional numeric vector (fixed) weights internally passed nlme::nlme() via nlme::varPower(). present, objective function weighted least squares. suppress_all Logical. Set TRUE avoid seeing errors messages model fitting procedure. Default FALSE. FALSE, also runs nlme() verbose = TRUE. timeout_n upper limit model fitting attempts. Default 10000. return_figure Whether return ggplot graph rhythm cosine model. control list. Used control parameterization model.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single_mixed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"circa_single_mixed — circa_single_mixed","text":"list","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circa_single_mixed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"circa_single_mixed — circa_single_mixed","text":"","code":"# \\donttest{ set.seed(42) mixed_data <- function(n) {   counter <- 1   for (i in 1:n) {     x <- make_data(k1 = rnorm(1, 10, 2), alpha1 = 0, phi1 = 0)     x$id <- counter     counter <- counter + 1     if (i == 1) {       res <- x     } else {       res <- rbind(res, x)     }   }   return(res) } df <- mixed_data(n = 50) out <- circa_single_mixed(   x = df, col_time = \"time\", col_outcome = \"measure\",   col_id = \"id\", randomeffects = c(\"k\") ) #>  #> **Iteration 1 #> LME step: Loglik: -14555.4, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.849877  #> varStruct  parameters: #> power  #>     0  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  119440.9  #>  fixed effects: 4.871085  9.996911  6.282769   #>  iterations: 7  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 6.330160e-01 1.068408e-08 0.000000e+00  #>  #> **Iteration 2 #> LME step: Loglik: -14555.4, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.849877  #> varStruct  parameters: #> power  #>     0  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  119440.9  #>  fixed effects: 4.871085  9.997704  6.283142   #>  iterations: 2  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 7.928814e-05 2.119202e-11 0.000000e+00  #>  #> **Iteration 3 #> LME step: Loglik: -14555.4, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.849877  #> varStruct  parameters: #> power  #>     0  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  119440.9  #>  fixed effects: 4.871085  9.997704  6.283142   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 2.400641e-16 0.000000e+00   # with sample weights (arbitrary weights for demonstration) sw <- runif(n = nrow(df)) out2 <- circa_single_mixed(   x = df, col_time = \"time\", col_outcome = \"measure\",   col_id = \"id\", randomeffects = c(\"k\"), weights = sw ) #>  #> **Iteration 1 #> LME step: Loglik: -14555.3, nlminb iterations: 5 #> reStruct  parameters: #>       id  #> 1.846839  #> varStruct  parameters: #>        power  #> -0.004554618  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  -9.997382  -3.14169   #>  iterations: 5  #> Convergence crit. (must all become <= tolerance = 1e-05): #>       fixed    reStruct   varStruct  #> 3.626909488 0.001645516 1.000000000  #>  #> **Iteration 2 #> LME step: Loglik: -14555.3, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.846838  #> varStruct  parameters: #>        power  #> -0.004554618  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  -9.997382  -3.14169   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 2.404592e-16 0.000000e+00  #>  #> **Iteration 1 #> LME step: Loglik: -14555.3, nlminb iterations: 5 #> reStruct  parameters: #>       id  #> 1.846839  #> varStruct  parameters: #>       power  #> -0.00455462  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997689  -6.283279   #>  iterations: 7  #> Convergence crit. (must all become <= tolerance = 1e-05): #>       fixed    reStruct   varStruct  #> 0.713215604 0.001645519 1.000000000  #>  #> **Iteration 2 #> LME step: Loglik: -14555.3, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.846838  #> varStruct  parameters: #>       power  #> -0.00455462  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997689  -6.283279   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 4.809184e-16 0.000000e+00  #>  #> **Iteration 1 #> LME step: Loglik: -14555.3, nlminb iterations: 5 #> reStruct  parameters: #>       id  #> 1.846839  #> varStruct  parameters: #>        power  #> -0.004554619  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997592  -0.0001218503   #>  iterations: 5  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 6.466667e+03 1.645512e-03 1.000000e+00  #>  #> **Iteration 2 #> LME step: Loglik: -14555.3, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.846838  #> varStruct  parameters: #>        power  #> -0.004554619  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997592  -0.0001218503   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 1.202296e-16 0.000000e+00  #>  #> **Iteration 1 #> LME step: Loglik: -14555.3, nlminb iterations: 5 #> reStruct  parameters: #>       id  #> 1.846839  #> varStruct  parameters: #>        power  #> -0.004554616  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997576  -0.0001508803   #>  iterations: 4  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 1.723537e+03 1.645516e-03 1.000000e+00  #>  #> **Iteration 2 #> LME step: Loglik: -14555.3, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.846838  #> varStruct  parameters: #>        power  #> -0.004554616  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997576  -0.0001508803   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 9.618367e-16 0.000000e+00  #>  #> **Iteration 1 #> LME step: Loglik: -14555.3, nlminb iterations: 5 #> reStruct  parameters: #>       id  #> 1.846839  #> varStruct  parameters: #>        power  #> -0.004554617  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  -9.997687  3.141499   #>  iterations: 5  #> Convergence crit. (must all become <= tolerance = 1e-05): #>       fixed    reStruct   varStruct  #> 3.640205877 0.001645513 1.000000000  #>  #> **Iteration 2 #> LME step: Loglik: -14555.3, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.846838  #> varStruct  parameters: #>        power  #> -0.004554617  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  -9.997687  3.141499   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 3.606888e-16 0.000000e+00  #>  #> **Iteration 1 #> LME step: Loglik: -14555.3, nlminb iterations: 5 #> reStruct  parameters: #>       id  #> 1.846839  #> varStruct  parameters: #>       power  #> -0.00455462  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997639  -12.56646   #>  iterations: 7  #> Convergence crit. (must all become <= tolerance = 1e-05): #>       fixed    reStruct   varStruct  #> 0.823382885 0.001645514 1.000000000  #>  #> **Iteration 2 #> LME step: Loglik: -14555.3, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.846838  #> varStruct  parameters: #>       power  #> -0.00455462  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997639  -12.56646   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 2.286767e-13 0.000000e+00  #>  #> **Iteration 1 #> LME step: Loglik: -14555.3, nlminb iterations: 5 #> reStruct  parameters: #>       id  #> 1.846839  #> varStruct  parameters: #>        power  #> -0.004554617  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997392  6.283087   #>  iterations: 7  #> Convergence crit. (must all become <= tolerance = 1e-05): #>       fixed    reStruct   varStruct  #> 1.193914453 0.001645507 1.000000000  #>  #> **Iteration 2 #> LME step: Loglik: -14555.3, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.846838  #> varStruct  parameters: #>        power  #> -0.004554617  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  118355.2  #>  fixed effects: 4.871032  9.997392  6.283087   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 3.515136e-10 0.000000e+00  # }"},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare.html","id":null,"dir":"Reference","previous_headings":"","what":"circacompare — circacompare","title":"circacompare — circacompare","text":"circacompare performs comparison two rhythmic groups data. tests rhythmicity fits nonlinear model parametrization estimate statistically support differences mesor, amplitude, phase groups.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"circacompare — circacompare","text":"","code":"circacompare(   x,   col_time,   col_group,   col_outcome,   period = 24,   alpha_threshold = 0.05,   timeout_n = 10000,   control = list(),   weights = NULL,   suppress_all = FALSE )"},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"circacompare — circacompare","text":"x data.frame.  data.frame contains rhythmic data two groups tidy format. col_time name column within data.frame, x, contains time hours data collected. col_group name column within data.frame, x, contains grouping variable.  two levels. col_outcome name column within data.frame, x, contains outcome measure interest. period period rhythm. circadian rhythms, leave default value, 24. alpha_threshold level alpha presence rhythmicity considered. Default 0.05. timeout_n upper limit model fitting attempts. Default 10,000. control list. Used control parameterization model. weights optional numeric vector (fixed) weights. present, objective function weighted least squares. suppress_all Logical. Set TRUE avoid seeing errors messages model fitting procedure. Default FALSE.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"circacompare — circacompare","text":"list","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"circacompare — circacompare","text":"","code":"df <- make_data(phi1 = 6) out <- circacompare(   x = df, col_time = \"time\", col_group = \"group\",   col_outcome = \"measure\" ) out #> $plot  #>  #> $summary #>                                   parameter          value #> 1  Presence of rhythmicity (p-value) for g1   7.742499e-83 #> 2  Presence of rhythmicity (p-value) for g2   9.953293e-91 #> 3                         g1 mesor estimate   1.089967e-02 #> 4                         g2 mesor estimate   2.995890e+00 #> 5                 Mesor difference estimate   2.984990e+00 #> 6              P-value for mesor difference  1.039187e-104 #> 7                     g1 amplitude estimate   1.000437e+01 #> 8                     g2 amplitude estimate   1.401390e+01 #> 9             Amplitude difference estimate   4.009528e+00 #> 10         P-value for amplitude difference  1.043910e-102 #> 11                       g1 peak time hours   2.399305e+01 #> 12                       g2 peak time hours   2.292035e+01 #> 13                Phase difference estimate  -1.072698e+00 #> 14          P-value for difference in phase   2.308806e-94 #> 15                   Shared period estimate   2.400000e+01 #>  #> $fit #> Nonlinear regression model #>   model: measure ~ (k + k1 * x_group) + ((alpha + alpha1 * x_group)) *     cos((1/period) * time_r - ((phi + phi1 * x_group))) #>    data: x #>       k      k1   alpha  alpha1     phi    phi1  #>  0.0109  2.9850 10.0044  4.0095 12.5646 -0.2808  #>  residual sum-of-squares: 1.11 #>  #> Number of iterations to convergence: 6  #> Achieved convergence tolerance: 4.046e-08 #>   # with sample weights (arbitrary weights for demonstration) sw <- runif(n = nrow(df)) out2 <- circacompare(   x = df, col_time = \"time\", col_group = \"group\",   col_outcome = \"measure\", weights = sw ) out2 #> $plot  #>  #> $summary #>                                   parameter          value #> 1  Presence of rhythmicity (p-value) for g1   3.989106e-85 #> 2  Presence of rhythmicity (p-value) for g2   7.489870e-92 #> 3                         g1 mesor estimate  -1.406791e-02 #> 4                         g2 mesor estimate   2.989707e+00 #> 5                 Mesor difference estimate   3.003775e+00 #> 6              P-value for mesor difference  2.973994e-108 #> 7                     g1 amplitude estimate   1.000604e+01 #> 8                     g2 amplitude estimate   1.401206e+01 #> 9             Amplitude difference estimate   4.006026e+00 #> 10         P-value for amplitude difference  7.126206e-106 #> 11                       g1 peak time hours   2.399457e+01 #> 12                       g2 peak time hours   2.291459e+01 #> 13                Phase difference estimate  -1.079979e+00 #> 14          P-value for difference in phase   2.858438e-97 #> 15                   Shared period estimate   2.400000e+01 #>  #> $fit #> Nonlinear regression model #>   model: measure ~ (k + k1 * x_group) + ((alpha + alpha1 * x_group)) *     cos((1/period) * time_r - ((phi + phi1 * x_group))) #>    data: x #>         k        k1     alpha    alpha1       phi      phi1  #> -0.014068  3.003775 10.006039  4.006026 -0.001421 -0.282738  #>  weighted residual sum-of-squares: 0.4322 #>  #> Number of iterations to convergence: 5  #> Achieved convergence tolerance: 3.213e-07 #>"},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare_mixed.html","id":null,"dir":"Reference","previous_headings":"","what":"circacompare_mixed — circacompare_mixed","title":"circacompare_mixed — circacompare_mixed","text":"circacompare_mixed similar circacompare allows simple, user-specified random-effects rhythmic parameters choice.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare_mixed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"circacompare_mixed — circacompare_mixed","text":"","code":"circacompare_mixed(   x,   col_time,   col_group,   col_outcome,   col_id,   randomeffects = c(),   period = 24,   alpha_threshold = 0.05,   nlme_control = list(),   nlme_method = \"REML\",   weights = NULL,   suppress_all = FALSE,   timeout_n = 10000,   control = list() )"},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare_mixed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"circacompare_mixed — circacompare_mixed","text":"x data.frame.  data.frame contains rhythmic data two groups tidy format. col_time name column within data.frame, x, contains time hours data collected. col_group name column within data.frame, x, contains grouping variable.  two levels. col_outcome name column within data.frame, x, contains outcome measure interest. col_id name column within data.frame, x, contains identifying values random effect, subject_id. randomeffects rhythmic parameters allow random effects. default include rhythmic parameters. period period rhythm. circadian rhythms, leave default value, 24. alpha_threshold level alpha presence rhythmicity considered. Default 0.05. nlme_control list control values estimation algorithm replace default values returned function nlme::nlmeControl. Defaults empty list. nlme_method character string. \"REML\" model fit maximizing restricted log-likelihood. \"ML\" log-likelihood maximized. Defaults \"REML\". weights optional numeric vector (fixed) weights internally passed nlme::nlme() via nlme::varPower(). present, objective function weighted least squares. suppress_all Logical. Set TRUE avoid seeing errors messages model fitting procedure. Default FALSE. FALSE, also runs nlme() verbose = TRUE. timeout_n upper limit model fitting attempts. Default 10000. control list. Used control parameterization model.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare_mixed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"circacompare_mixed — circacompare_mixed","text":"list","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/circacompare_mixed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"circacompare_mixed — circacompare_mixed","text":"","code":"# Generate some data with within-id correlation for phase-shift (phi1) # \\donttest{ set.seed(99) phi1_in <- 3.15  mixed_data <- function(n) {   counter <- 1   for (i in 1:n) {     x <- make_data(k1 = 0, alpha1 = 0, phi1 = rnorm(1, phi1_in, 0.5), hours = 72, noise_sd = 1)     x$id <- counter     counter <- counter + 1     if (i == 1) {       res <- x     } else {       res <- rbind(res, x)     }   }   return(res) } df <- mixed_data(20) out <- circacompare_mixed(   x = df,   col_time = \"time\",   col_group = \"group\",   col_outcome = \"measure\",   col_id = \"id\",   control = list(grouped_params = c(\"phi\"), random_params = c(\"phi1\")) ) #>  #> **Iteration 1 #> LME step: Loglik: -5362.31, nlminb iterations: 1 #> reStruct  parameters: #>       id  #> 1.330561  #> varStruct  parameters: #> power  #>     0  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  2914.277  #>  fixed effects: -0.003046635  10.00689  0.001165668  3.036078   #>  iterations: 5  #> Convergence crit. (must all become <= tolerance = 1e-05): #>     fixed  reStruct varStruct  #>  2.841335  0.718343  0.000000  #>  #> **Iteration 2 #> LME step: Loglik: -4181.778, nlminb iterations: 3 #> reStruct  parameters: #>        id  #> 0.7491786  #> varStruct  parameters: #> power  #>     0  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  2914.277  #>  fixed effects: -0.003046635  10.00689  0.001165668  3.036078   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>     fixed  reStruct varStruct  #>         0         0         0   # with sample weights (arbitrary weights for demonstration) sw <- runif(n = nrow(df)) out2 <- circacompare_mixed(   x = df,   col_time = \"time\",   col_group = \"group\",   col_outcome = \"measure\",   col_id = \"id\",   control = list(grouped_params = c(\"phi\"), random_params = c(\"phi1\")),   weights = sw ) #>  #> **Iteration 1 #> LME step: Loglik: -9253.195, nlminb iterations: 5 #> reStruct  parameters: #>       id  #> 3.094586  #> varStruct  parameters: #>        power  #> -0.002104771  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  2902.204  #>  fixed effects: -0.003036673  10.00696  0.001187815  2.721892   #>  iterations: 7  #> Convergence crit. (must all become <= tolerance = 1e-05): #>     fixed  reStruct varStruct  #>   7.58760  17.93843   1.00000  #>  #> **Iteration 2 #> LME step: Loglik: -4199.912, nlminb iterations: 7 #> reStruct  parameters: #>         id  #> -0.2066936  #> varStruct  parameters: #>         power  #> -0.0008370184  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  2909.464  #>  fixed effects: -0.00304237  10.00692  0.001174652  2.721905   #>  iterations: 2  #> Convergence crit. (must all become <= tolerance = 1e-05): #>       fixed    reStruct   varStruct  #> 0.011205726 0.006916916 1.514605343  #>  #> **Iteration 3 #> LME step: Loglik: -4199.912, nlminb iterations: 8 #> reStruct  parameters: #>         id  #> -0.2066936  #> varStruct  parameters: #>        power  #> -0.000836894  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  2909.464  #>  fixed effects: -0.00304237  10.00692  0.001174652  2.721905   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 6.778246e-07 1.485866e-04  #>  #> **Iteration 4 #> LME step: Loglik: -4199.912, nlminb iterations: 8 #> reStruct  parameters: #>         id  #> -0.2066936  #> varStruct  parameters: #>        power  #> -0.000836894  #>  Beginning PNLS step: ..  completed fit_nlme() step. #> PNLS step: RSS =  2909.464  #>  fixed effects: -0.00304237  10.00692  0.001174652  2.721905   #>  iterations: 1  #> Convergence crit. (must all become <= tolerance = 1e-05): #>        fixed     reStruct    varStruct  #> 0.000000e+00 9.486459e-11 2.079497e-08  # }"},{"path":"https://rwparsons.github.io/circacompare/reference/make_data.html","id":null,"dir":"Reference","previous_headings":"","what":"make_data — make_data","title":"make_data — make_data","text":"Generate example circadian data specified phase shift groups","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/make_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"make_data — make_data","text":"","code":"make_data(   k = 0,   k1 = 3,   alpha = 10,   alpha1 = 4,   phi = 0,   phi1 = 3.15,   tau = 24,   hours = 48,   noise_sd = 0.1,   seed = NULL )"},{"path":"https://rwparsons.github.io/circacompare/reference/make_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"make_data — make_data","text":"k mesor group 1. k1 change mesor group 2 group 1. alpha amplitude rhythm group 1. alpha1 change amplitude group 2 group 1 phi phase rhythm, radian-hours, group 1. phi1 change phase, radian-hours, group 2 group 1 tau period rhythm, shared groups. hours number hours/datapoints sample. noise_sd standard deviation noise term. seed random seed generating data.","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/make_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"make_data — make_data","text":"data.frame","code":""},{"path":"https://rwparsons.github.io/circacompare/reference/make_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"make_data — make_data","text":"","code":"data <- make_data(k1 = 3, alpha1 = 4, phi1 = 6)"},{"path":[]},{"path":"https://rwparsons.github.io/circacompare/news/index.html","id":"improvements-0-1-1-9000","dir":"Changelog","previous_headings":"","what":"Improvements","title":"circacompare 0.1.1.9000","text":"support per-sample weights circacompare(), circa_single(), circa_single_mixed() circacompare_mixed() better error messages - also makes shiny app verbose users allow user use suppress_all argument show/hide messages model fitting across circacompare functions. allow user specify use linear model (non-mixed) fitting models group using circacompare_mixed(). (Faster computation!)","code":""},{"path":"https://rwparsons.github.io/circacompare/news/index.html","id":"circacompare-011","dir":"Changelog","previous_headings":"","what":"circacompare 0.1.1","title":"circacompare 0.1.1","text":"CRAN release: 2021-04-20","code":""},{"path":"https://rwparsons.github.io/circacompare/news/index.html","id":"improvements-0-1-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"circacompare 0.1.1","text":"User-definable parameters functions. Notably: period can estimated rather always user-defined, rhythmic characteristics can selectively shared groups, parameters can additional decay terms decay terms can group-effects determine differences decay groups. informative summary tables models.","code":""},{"path":"https://rwparsons.github.io/circacompare/news/index.html","id":"bug-fixes-0-1-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"circacompare 0.1.1","text":"sensible default values random effects. nlme used estimating presence rhythmicity group circacompare_mixed() used, rather nls.","code":""}]
